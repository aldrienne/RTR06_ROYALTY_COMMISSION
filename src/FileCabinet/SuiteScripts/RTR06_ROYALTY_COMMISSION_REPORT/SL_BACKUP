/**
 * @NApiVersion 2.1
 * @NScriptType Suitelet
 * @description Royalty/Commission Management Suitelet
 */
define(['N/ui/serverWidget', 'N/search', 'N/record', 'N/format', 'N/url', 'N/query', 'N/redirect'],

    (serverWidget, search, record, format, url, query, redirect) => {


        let SUITELET_ID = "customscript_tsc_sl_royalty_report";
        let SUITELET_DEPLOYMENT_ID = "customdeploy1";
        /**
         * Defines the Suitelet script trigger point.
         * @param {Object} scriptContext
         * @param {ServerRequest} scriptContext.request - Incoming request
         * @param {ServerResponse} scriptContext.response - Suitelet response
         * @since 2015.2
         */
        const onRequest = (scriptContext) => {
            try {
                if (scriptContext.request.method === 'GET') {
                    handleGet(scriptContext);
                } else {
                    handlePost(scriptContext);
                }
            } catch (e) {
                log.error('Royalty Management Suitelet Error', e.message);
                scriptContext.response.write('An error occurred: ' + e.message);
            }
        };

        /**
 * Handles GET requests
 * @param {Object} scriptContext
 */
        const handleGet = (scriptContext) => {
            const form = serverWidget.createForm({
                title: 'Royalty Management',
                hideNavBar: false
            });

            // Add client script to form
            form.clientScriptModulePath = './tsc_cs_royalty_report.js';

            const reportingTab = form.addTab({
                id: 'custpage_reporting_tab',
                label: 'Reporting'
            });

            // Add a tab for the two main sections
            const configTab = form.addTab({
                id: 'custpage_config_tab',
                label: 'Configuration'
            });

            // Create Reporting Tab Content
            createReportingTab(form, reportingTab);

            // Create Configuration Tab Content
            createConfigurationTab(form, configTab);

            // Add submit button
            form.addSubmitButton({
                label: 'Save Configuration'
            });

            // Check if we need to run a report based on request parameters
            const action = scriptContext.request.parameters.custpage_action;

            // Set filter values if they exist in parameters
            setFilterValuesFromRequest(form, scriptContext.request);

            if (action === 'report') {
                // Generate report based on filters
                generateReport(form, scriptContext.request);
            } else if (action === 'exportcsv') {
                // Handle CSV export - this will bypass normal form rendering
                return exportReportToCSV(scriptContext);
            }

            scriptContext.response.writePage(form);
        };

        /**
         * Creates the Configuration tab content
         * @param {serverWidget.Form} form - The form object
         * @param {serverWidget.Tab} tab - The tab object
         */
        const createConfigurationTab = (form, tab) => {
            // Create editable sublist for royalty categories
            const categorySublist = form.addSublist({
                id: 'custpage_royalty_categories',
                type: serverWidget.SublistType.EDITOR,
                label: 'Royalty Categories',
                tab: 'custpage_config_tab'
            });

            // Add sublist fields
            categorySublist.addField({
                id: 'custpage_category_id',
                type: serverWidget.FieldType.TEXT,
                label: 'ID'
            }).updateDisplayType({
                displayType: serverWidget.FieldDisplayType.HIDDEN
            });

            // Add Royalty Name field
            categorySublist.addField({
                id: 'custpage_category_name',
                type: serverWidget.FieldType.TEXT,
                label: 'Royalty'
            }).updateDisplayType({
                displayType: serverWidget.FieldDisplayType.DISABLED
            });

            // Add Split Percentage field
            categorySublist.addField({
                id: 'custpage_split_percentage',
                type: serverWidget.FieldType.PERCENT,
                label: 'Split (%)'
            })

            categorySublist.addField({
                id: 'custrecord_tsc_calc_perc_by',
                type: 'select',
                label: 'Calculation Method',
                source: 'customlist_tsc_calc_perc_by'
            });

            // Add Previous Split Percentage field
            const prevPercentField = categorySublist.addField({
                id: 'custpage_previous_percentage',
                type: serverWidget.FieldType.PERCENT,
                label: 'Previous Split (%)'
            }).updateDisplayType({
                displayType: serverWidget.FieldDisplayType.DISABLED
            });

            // Make Previous Percent field read-only
            // prevPercentField.updateDisplayType({
            //     displayType: serverWidget.FieldDisplayType.INLINE
            // });

            // Add Last Modified field
            categorySublist.addField({
                id: 'custpage_last_modified',
                type: serverWidget.FieldType.DATETIMETZ,
                label: 'Last Modified'
            }).updateDisplayType({
                displayType: serverWidget.FieldDisplayType.DISABLED
            });

            // Load existing royalty records
            loadRoyaltyRecords(categorySublist);
        };
        /**
         * Creates the Reporting tab content
         * @param {serverWidget.Form} form - The form object
         * @param {serverWidget.Tab} tab - The tab object
         */
        const createReportingTab = (form, tab) => {
            // Add filter fieldgroup
            const filterGroup = form.addFieldGroup({
                id: 'custpage_filter_group',
                label: 'Filters',
                tab: 'custpage_reporting_tab'
            });

            // Add date range fields
            form.addField({
                id: 'custpage_date_from',
                type: serverWidget.FieldType.DATE,
                label: 'From Date',
                container: 'custpage_filter_group'
            });

            form.addField({
                id: 'custpage_date_to',
                type: serverWidget.FieldType.DATE,
                label: 'To Date',
                container: 'custpage_filter_group'
            });

            // Add category filter field
            const categoryField = form.addField({
                id: 'custpage_category_filter',
                type: serverWidget.FieldType.SELECT,
                label: 'Royalty Category',
                container: 'custpage_filter_group'
            });

            const subsidiaryField = form.addField({
                id: "custpage_subsidiary_filter",
                type: serverWidget.FieldType.SELECT,
                label: "Subsidiary",
                source: "subsidiary",
                container: 'custpage_filter_group'
            });

            // Add percentage display field
            const percentageField = form.addField({
                id: 'custpage_category_percentage',
                type: serverWidget.FieldType.PERCENT,
                label: 'Royalty Percentage',
                container: 'custpage_filter_group'
            });
            percentageField.updateDisplayType({
                displayType: serverWidget.FieldDisplayType.INLINE
            });

            // Add "All Categories" option
            categoryField.addSelectOption({
                value: '',
                text: 'All Categories'
            });

            // Populate the filter dropdown with royalty records
            populateRoyaltyCategoryFilter(categoryField);

            // Add "Run Report" button
            form.addButton({
                id: 'custpage_run_report',
                label: 'Run Report',
                functionName: 'runReport'
            });

            // Add Export button
            form.addButton({
                id: 'custpage_export',
                label: 'Export CSV',
                functionName: 'exportReportCSV'
            });

            // Add an HTML field for the results table
            const resultsField = form.addField({
                id: 'custpage_results_html',
                type: serverWidget.FieldType.INLINEHTML,
                label: ' ',
                container: 'custpage_reporting_tab'  // Ensure it's in the reporting tab
            });

            // Set default content for the HTML field (empty table structure)
            let defaultHtml = `
    <div class="uir-field-wrapper uir-long-text" style="margin-top: 20px;">
        <div class="uir-field">
            <span class="smalltextb">Royalty Report Results</span>
            <div class="uir-field-value">
                <table id="custpage_royalty_results" class="uir-table" style="width: 100%; margin-top: 10px; border-collapse: collapse;">
                    <thead>
                        <tr>
                            <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f5f7fa;">Item Name</th>
                            <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f5f7fa;">Category</th>
                            <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f5f7fa;">Transaction</th>
                            <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f5f7fa;">Date</th>
                            <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f5f7fa;">Amount</th>
                            <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f5f7fa;">Royalty</th>
                        </tr>
                    </thead>
                    <tbody id="custpage_results_body">
                        <tr>
                            <td colspan="6" style="border: 1px solid #ddd; padding: 8px; text-align: center;">
                                No data to display. Please select filters and run the report.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    `;

            resultsField.defaultValue = defaultHtml;
        };
        /**
         * Handles POST requests
         * @param {Object} scriptContext
         */
        const handlePost = (scriptContext) => {
            // Save configurations
            handleSaveConfigurations(scriptContext);
            redirect.toSuitelet({
                scriptId: SUITELET_ID,
                deploymentId: SUITELET_DEPLOYMENT_ID
            });

        };

        /**
         * Handles saving configuration changes
         * @param {Object} scriptContext
         */
        const handleSaveConfigurations = (scriptContext) => {
            const request = scriptContext.request;

            // Get line count from the sublist
            const lineCount = request.getLineCount({
                group: 'custpage_royalty_categories'
            });

            // Process each line
            for (let i = 0; i < lineCount; i++) {
                const categoryId = request.getSublistValue({
                    group: 'custpage_royalty_categories',
                    name: 'custpage_category_id',
                    line: i
                });

                const splitPercentage = request.getSublistValue({
                    group: 'custpage_royalty_categories',
                    name: 'custpage_split_percentage',
                    line: i
                });

                const previousSplitPercentage = request.getSublistValue({
                    group: 'custpage_royalty_categories',
                    name: 'custpage_previous_percentage',
                    line: i
                });

                // Get calculation method value
                const calcPercentBy = request.getSublistValue({
                    group: 'custpage_royalty_categories',
                    name: 'custrecord_tsc_calc_perc_by',
                    line: i
                });

                log.audit('values', { splitPercentage, previousSplitPercentage, calcPercentBy });

                // Use Record.submitfields with updated values object
                record.submitFields({
                    type: 'customrecord_tsc_royalty',
                    id: categoryId,
                    values: {
                        custrecord_tsc_royalty_percent: splitPercentage,
                        custrecord_tsc_previous_percent: previousSplitPercentage,
                        custrecord_tsc_calc_perc_by: calcPercentBy
                    }
                });
            }
        };

        /**
         * Handles report generation
         * @param {Object} scriptContext
         */
        const handleReportGeneration = (scriptContext) => {
            // This would be implemented to update the HTML table
            // with the report results based on the filter criteria
        };

        /**
         * Handles CSV export
         * @param {Object} scriptContext
         */
        const handleCSVExport = (scriptContext) => {
            // This would be implemented to generate and output a CSV file
            // based on the filter criteria
        };

        /**
         * Helper function to load royalty records into the sublist
         * @param {serverWidget.Sublist} sublist - The sublist to populate
         */
        const loadRoyaltyRecords = (sublist) => {
            try {
                // Use N/query instead of N/search
                const queryResults = query.runSuiteQL({
                    query: `
                        SELECT
                            id,
                            name,
                            custrecord_tsc_royalty_percent,
                            custrecord_tsc_previous_percent,
                            custrecord_tsc_calc_perc_by,
                            TO_CHAR(lastmodified, 'MM/DD/YYYY HH:MI:SS AM') as lastmodified
                        FROM
                            customrecord_tsc_royalty
                        WHERE
                            isinactive = 'F'
                        ORDER BY
                            name ASC
                    `
                });

                // Get the mapped results
                const records = queryResults.asMappedResults();

                log.audit('Royalty Records', records.length);

                let lineCount = 0;

                // Explicitly iterate through array with for loop instead of forEach
                for (let i = 0; i < records.length; i++) {
                    const result = records[i];
                    log.debug('Processing record', JSON.stringify(result) + ' at index ' + i);

                    // Set ID (hidden)
                    sublist.setSublistValue({
                        id: 'custpage_category_id',
                        line: lineCount,
                        value: result.id.toString()
                    });

                    // Set Name/Royalty
                    sublist.setSublistValue({
                        id: 'custpage_category_name',
                        line: lineCount,
                        value: result.name || ''
                    });

                    // Set Split Percentage
                    if (result.custrecord_tsc_royalty_percent !== null) {
                        sublist.setSublistValue({
                            id: 'custpage_split_percentage',
                            line: lineCount,
                            value: (parseFloat(result.custrecord_tsc_royalty_percent) * 100).toString()
                        });
                    }

                    // Set Previous Split Percentage
                    if (result.custrecord_tsc_previous_percent !== null) {
                        sublist.setSublistValue({
                            id: 'custpage_previous_percentage',
                            line: lineCount,
                            value: result.custrecord_tsc_previous_percent.toString()
                        });
                    }

                    // Set Last Modified
                    if (result.lastmodified) {
                        sublist.setSublistValue({
                            id: 'custpage_last_modified',
                            line: lineCount,
                            value: result.lastmodified
                        });
                    }

                    // Inside the loop where you're setting sublist values:
                    if (result.custrecord_tsc_calc_perc_by) {
                        sublist.setSublistValue({
                            id: 'custrecord_tsc_calc_perc_by',
                            line: lineCount,
                            value: result.custrecord_tsc_calc_perc_by.toString()
                        });
                    }

                    log.debug('Completed setting values for line', lineCount);
                    lineCount++;
                }

                log.debug('Royalty Records Processing Complete', lineCount + ' records loaded into sublist');
            } catch (e) {
                log.error('Error loading royalty records', e.message);
                log.error('Error stack', e.stack);
            }
        };

        /**
         * Helper function to populate the royalty category filter dropdown
         * @param {serverWidget.Field} selectField - The select field to populate
         */
        const populateRoyaltyCategoryFilter = (selectField) => {
            try {
                // Use N/query instead of N/search
                const queryResults = query.runSuiteQL({
                    query: `
                SELECT
                    id,
                    name,
                    custrecord_tsc_royalty_percent
                FROM
                    customrecord_tsc_royalty
                WHERE
                    isinactive = 'F'
                ORDER BY
                    name ASC
            `
                });

                // Get the mapped results
                const records = queryResults.asMappedResults();

                // Add options to select field
                records.forEach(function (result) {
                    selectField.addSelectOption({
                        value: result.id.toString(),
                        text: result.name
                    });
                });

            } catch (e) {
                log.error('Error populating royalty category filter', e);
            }
        };
        /**
 * Sets filter values on the form based on request parameters
 * @param {serverWidget.Form} form - The form object
 * @param {ServerRequest} request - The request object
 */
        const setFilterValuesFromRequest = (form, request) => {
            const fromDate = request.parameters.custpage_date_from;
            const toDate = request.parameters.custpage_date_to;
            const categoryId = request.parameters.custpage_category_filter;
            const subsidiaryId = request.parameters.custpage_subsidiary_filter;


            if (fromDate) {
                form.getField({ id: 'custpage_date_from' }).defaultValue = fromDate;
            }

            if (toDate) {
                form.getField({ id: 'custpage_date_to' }).defaultValue = toDate;
            }

            if (categoryId) {
                form.getField({ id: 'custpage_category_filter' }).defaultValue = categoryId;

                // Also set the percentage field if a category is selected
                updatePercentageField(form, categoryId);
            }

            if (subsidiaryId) {
                form.getField({ id: 'custpage_subsidiary_filter' }).defaultValue = subsidiaryId;
            }


        };

        /**
         * Updates the percentage field based on selected category
         * @param {serverWidget.Form} form - The form object
         * @param {string} categoryId - The selected category ID
         */
        const updatePercentageField = (form, categoryId) => {
            if (!categoryId) return;

            try {
                // Query the percentage for this category
                const queryResult = query.runSuiteQL({
                    query: `
                SELECT custrecord_tsc_royalty_percent
                FROM customrecord_tsc_royalty
                WHERE id = ?
            `,
                    params: [categoryId]
                });

                const results = queryResult.asMappedResults();

                if (results.length > 0 && results[0].custrecord_tsc_royalty_percent !== null) {
                    const percentageField = form.getField({ id: 'custpage_category_percentage' });
                    percentageField.defaultValue = parseFloat(results[0].custrecord_tsc_royalty_percent) * 100;
                }
            } catch (e) {
                log.error('Error updating percentage field', e);
            }
        };

        /**
         * Creates the royalty report search with the specified filters
         * @param {Object} filters - Object containing filter parameters
         * @param {string} [filters.fromDate] - Start date for filtering
         * @param {string} [filters.toDate] - End date for filtering
         * @param {string} [filters.categoryId] - Royalty category ID
         * @returns {search.Search} - The configured search object
         */
        const createRoyaltyReportSearch = (filters) => {
            log.debug('filters', JSON.stringify(filters));
            // Create the base transaction search

            let searchFilters = [
                ['type', 'anyof', 'CashSale', 'CustInvc', 'CustCred', 'CashRfnd'],
                "AND",
                ["mainline", "is", "F"],
                "AND",
                ["taxline", "is", "F"],
                "AND",
                ["shipping", "is", "F"],
                "AND",
                ["transactiondiscount", "is", "F"],
                "AND",
                ["rate", "greaterthanorequalto", "0.00"]
            ];

            //Add filters here

            if (filters.categoryId) {
                searchFilters.push("AND");
                searchFilters.push(["item.custitem_tsc_royalty", "anyof", filters.categoryId]);
            }
            log.emergency('filters', filters);

            if (filters.subsidiaryId) {
                log.emergency('subsidiaryId', filters.subsidiaryId);
                searchFilters.push("AND");
                searchFilters.push(["subsidiary", "anyof", filters.subsidiaryId]);
            }

            if (filters.fromDate) {
                searchFilters.push("AND");
                searchFilters.push(["trandate", "onorafter", filters.fromDate]);
            }

            if (filters.toDate) {
                searchFilters.push("AND");
                searchFilters.push(["trandate", "onorbefore", filters.toDate]);
            }

            const transactionSearchColInternalId = search.createColumn({ name: 'internalid', summary: search.Summary.GROUP });
            const transactionSearchColItem = search.createColumn({ name: 'item', summary: search.Summary.GROUP });
            const transactionSearchColTranDate = search.createColumn({ name: 'trandate', summary: search.Summary.GROUP });
            const transactionSearchColTranId = search.createColumn({ name: 'tranid', summary: search.Summary.GROUP, sort: search.Sort.ASC });
            const transactionSearchColQuantity = search.createColumn({ name: 'quantity', summary: search.Summary.SUM });
            const transactionSearchColItemRate = search.createColumn({ name: 'rate', summary: search.Summary.MAX });
            const transactionSearchColAmountGross = search.createColumn({ name: 'grossamount', summary: search.Summary.SUM });
            const transactionSearchColAmountNetOfTax = search.createColumn({ name: 'netamountnotax', summary: search.Summary.SUM });
            const transactionSearchColAmountTax = search.createColumn({ name: 'taxamount', summary: search.Summary.SUM });
            const transactionSearchColAmountDiscount = search.createColumn({ name: 'discountamount', summary: search.Summary.SUM });
            const transactionSearchColFormulaCurrencySBBHM = search.createColumn({ name: 'formulacurrency', summary: search.Summary.SUM, formula: 'NVL({netamountnotax}, 0) + NVL({taxamount}, 0)' });
            const transactionSearchColItemRoyalty = search.createColumn({ name: 'custitem_tsc_royalty', join: 'item', summary: search.Summary.GROUP });
            const transactionSearchColCreatedFrom = search.createColumn({ name: 'createdfrom', summary: search.Summary.GROUP });
            const transactionSearchColType = search.createColumn({ name: 'type', summary: search.Summary.GROUP });
            const transactionSearchColEstExtendedCostLine = search.createColumn({ name: 'costestimate', summary: search.Summary.SUM });

            const transactionSearch = search.create({
                type: "transaction",
                settings: [{ "name": "consolidationtype", "value": "ACCTTYPE" }],
                filters: searchFilters,
                columns: [
                    transactionSearchColItem,
                    transactionSearchColTranDate,
                    transactionSearchColTranId,
                    transactionSearchColQuantity,
                    transactionSearchColItemRate,
                    transactionSearchColAmountGross,
                    transactionSearchColAmountNetOfTax,
                    transactionSearchColAmountTax,
                    transactionSearchColAmountDiscount,
                    transactionSearchColFormulaCurrencySBBHM,
                    transactionSearchColItemRoyalty,
                    transactionSearchColCreatedFrom,
                    transactionSearchColType,
                    transactionSearchColInternalId,
                    transactionSearchColEstExtendedCostLine
                ]
            });
            let results = [];

            //Execute Search
            const transactionSearchPagedData = transactionSearch.runPaged({ pageSize: 1000 });
            for (let i = 0; i < transactionSearchPagedData.pageRanges.length; i++) {
                const transactionSearchPage = transactionSearchPagedData.fetch({ index: i });
                transactionSearchPage.data.forEach((result) => {
                    let tempObj = {};
                    const transactionType = result.getText(transactionSearchColType);
                    tempObj['id'] = result.getValue(transactionSearchColInternalId);
                    tempObj['type'] = transactionType;
                    tempObj['roycalCategory'] = result.getText(transactionSearchColItemRoyalty)
                    tempObj['productTitle'] = result.getText(transactionSearchColItem)
                    tempObj['orderNumber'] = result.getValue(transactionSearchColTranId)
                    tempObj['tranDate'] = result.getValue(transactionSearchColTranDate)
                    tempObj['quantity'] = result.getValue(transactionSearchColQuantity)
                    tempObj['rate'] = result.getValue(transactionSearchColItemRate)
                    tempObj['grossSale'] = result.getValue(transactionSearchColAmountGross)
                    tempObj['amountNetOfTax'] = result.getValue(transactionSearchColAmountNetOfTax)
                    tempObj['amountTax'] = result.getValue(transactionSearchColAmountTax)
                    tempObj['amountDiscount'] = result.getValue(transactionSearchColAmountDiscount)
                    tempObj['totalSales'] = result.getValue(transactionSearchColFormulaCurrencySBBHM)
                    tempObj['totalCost'] = result.getValue(transactionSearchColEstExtendedCostLine);
                    if (transactionType === 'Cash Refund' || transactionType === 'Credit Memo') {
                        tempObj['isReturn'] = true;
                        tempObj['createdFrom'] = result.getValue(transactionSearchColCreatedFrom);
                        log.emergency('tempObj', tempObj);

                    }
                    results.push(tempObj);
                });
            }


            // // Add category filter if provided
            // if (filters.categoryId && filters.categoryId !== '') {
            //     transactionSearchObj.filters.push("AND");
            //     transactionSearchObj.filters.push(["custitem_tsc_royalty", "anyof", filters.categoryId]);
            // }

            return results;
        };

        /**
         * Processes raw transaction data to organize sales with their related refunds
         * @param {Array} results - Raw results from createRoyaltyReportSearch
         * @returns {Object} - Structured data with sales and their related refunds
         */
        const processRoyaltyReportData = (results) => {
            try {
                // Initialize the data structure
                const processedData = {
                    salesMap: {},
                    orphanedRefunds: [],
                    flattenedRecords: [],
                    totals: {
                        totalGross: 0,
                        totelNet: 0,
                        totalCost: 0,
                        totalTax: 0
                    }
                };

                // First pass: separate sales from refunds
                const refunds = [];

                results.forEach(transaction => {
                    if (!transaction) {
                        log.error('Undefined transaction found in results array');
                        return; // Skip this iteration
                    }

                    // Parse numeric values to ensure proper calculations
                    ['quantity', 'rate', 'grossSale', 'amountNetOfTax', 'amountTax',
                        'amountDiscount', 'totalSales', 'totalCost'].forEach(field => {
                            transaction[field] = parseFloat(transaction[field] || 0);
                        });

                    if (transaction.isReturn) {
                        // Add to refunds array for second pass
                        refunds.push(transaction);
                    } else {
                        // Add to sales map with empty refunds array
                        processedData.salesMap[transaction.id] = {
                            sale: transaction,
                            relatedRefunds: [],
                            computedMetrics: {
                                netQuantity: transaction.quantity || 0,
                                netGrossSale: transaction.grossSale || 0,
                                netAmountNetOfTax: transaction.amountNetOfTax || 0,
                                netAmountTax: transaction.amountTax || 0,
                                netTotalSales: transaction.totalSales || 0,
                                totalCost: transaction.totalCost || 0,
                                hasRefunds: false
                            }
                        };
                    }
                });

                log.audit('results length', results.length);
                log.audit('refunds length', refunds.length);

                // Second pass: associate refunds with their sales
                refunds.forEach(refund => {
                    if (!refund) {
                        log.error('Undefined refund found in refunds array');
                        return; // Skip this iteration
                    }

                    const saleOrderNumber = refund.createdFrom;
                    log.audit('Processing refund', {
                        refundId: refund.id,
                        createdFrom: saleOrderNumber,
                        totalSales: refund.totalSales
                    });

                    if (saleOrderNumber && processedData.salesMap[saleOrderNumber]) {
                        // Found the matching sale - add to relatedRefunds
                        const saleEntry = processedData.salesMap[saleOrderNumber];
                        saleEntry.relatedRefunds.push(refund);
                        saleEntry.computedMetrics.hasRefunds = true;

                        // IMPORTANT FIX: Refund values are already negative, so ADD them
                        // instead of subtracting them to get the correct net values
                        saleEntry.computedMetrics.netQuantity += (refund.quantity || 0);
                        saleEntry.computedMetrics.netGrossSale += (refund.grossSale || 0);
                        saleEntry.computedMetrics.netAmountNetOfTax += (refund.amountNetOfTax || 0);
                        saleEntry.computedMetrics.netAmountTax += (refund.amountTax || 0);
                        saleEntry.computedMetrics.netTotalSales += (refund.totalSales || 0);
                        saleEntry.computedMetrics.totalCost += (refund.totalCost || 0);

                        log.audit('Updated metrics for sale ' + saleOrderNumber, {
                            netQuantity: saleEntry.computedMetrics.netQuantity,
                            netGrossSale: saleEntry.computedMetrics.netGrossSale,
                            netAmountNetOfTax: saleEntry.computedMetrics.netAmountNetOfTax,
                            netTotalSales: saleEntry.computedMetrics.netTotalSales,
                            totalCost: saleEntry.computedMetrics.totalCost
                        });
                    } else {
                        // Orphaned refund - no matching sale found
                        log.audit('Orphaned refund', {
                            refundId: refund.id,
                            createdFrom: saleOrderNumber
                        });
                        processedData.orphanedRefunds.push(refund);
                    }
                });

                // Create flattened records array for easy iteration in reports
                // First, add all sales with their computed metrics
                Object.values(processedData.salesMap).forEach(saleEntry => {
                    if (!saleEntry || !saleEntry.sale) {
                        log.error('Undefined sale entry found');
                        return; // Skip this iteration
                    }

                    // Calculate return amount as the difference between original sale and net after returns
                    // Use Math.abs to ensure positive value for display
                    const returnAmount = saleEntry.computedMetrics.hasRefunds ?
                        Math.abs((saleEntry.sale.totalSales || 0) - (saleEntry.computedMetrics.netTotalSales || 0)) : 0;

                    processedData.flattenedRecords.push({
                        ...saleEntry.sale,
                        returns: returnAmount,
                        netQuantity: saleEntry.computedMetrics.netQuantity || 0,
                        netGrossSale: saleEntry.computedMetrics.netGrossSale || 0,
                        netAmountNetOfTax: saleEntry.computedMetrics.netAmountNetOfTax || 0,
                        netTotalSales: saleEntry.computedMetrics.netTotalSales || 0,
                        hasReturns: saleEntry.computedMetrics.hasRefunds
                    });

                    //Add Totals Here
                    processedData.totals.totalGross += saleEntry.computedMetrics.netGrossSale || 0;
                    processedData.totals.totelNet += saleEntry.computedMetrics.netAmountNetOfTax || 0;
                    processedData.totals.totalCost += saleEntry.netTotalSales || 0;
                    processedData.totals.totalTax += saleEntry.computedMetrics.netAmountTax || 0;
                });

                // Then add orphaned refunds
                processedData.orphanedRefunds.forEach(refund => {
                    if (!refund) {
                        log.error('Undefined orphaned refund found');
                        return; // Skip this iteration
                    }

                    processedData.flattenedRecords.push({
                        ...refund,
                        isOrphanedReturn: true,
                        // For orphaned returns, just use the values directly (already negative)
                        netQuantity: refund.quantity || 0,
                        netGrossSale: refund.grossSale || 0,
                        netAmountNetOfTax: refund.amountNetOfTax || 0,
                        netTotalSales: refund.totalSales || 0
                    });
                });
                log.debug('PROCESSED', processedData.flattenedRecords);

                return processedData;
            } catch (e) {
                log.error('Error in processRoyaltyReportData', e);
                return {
                    salesMap: {},
                    orphanedRefunds: [],
                    flattenedRecords: results // Return original results as fallback
                };
            }
        };


        /**
         * Generates report based on filters using a transaction search
         * @param {serverWidget.Form} form - The form object
         * @param {ServerRequest} request - The request object
         */
        const generateReport = (form, request) => {
            try {
                // Get filter parameters from the request
                const filterParams = {
                    fromDate: request.parameters.custpage_date_from,
                    toDate: request.parameters.custpage_date_to,
                    categoryId: request.parameters.custpage_category_filter,
                    subsidiaryId: request.parameters.custpage_subsidiary_filter
                };

                // Get sales data
                const results = createRoyaltyReportSearch(filterParams);
                log.audit('results', results);

                const processedData = processRoyaltyReportData(results);
                log.emergency('processedData', processedData);

                const reportRecords = processedData.flattenedRecords;
                const totals = processedData.totals;
                // Generate HTML table rows
                let tableHtml = '';
                let totalRoyalty = 0;

                if (reportRecords.length > 0) {
                    // Process each result
                    reportRecords.forEach(result => {
                        const royaltyCategory = result.roycalCategory || '';
                        const productTitle = result.productTitle || '';
                        const orderNumber = result.orderNumber || '';
                        const tranDate = result.tranDate || '';
                        const quantity = result.quantity || 0;
                        const rate = result.rate || 0;
                        const grossSale = result.grossSale || 0;
                        const discounts = result.amountDiscount || 0;
                        const netSales = result.netAmountNetOfTax || 0;
                        const taxes = result.amountTax || 0;
                        const totalSales = result.netTotalSales || 0;
                        // Append table row
                        tableHtml += `
                <tr>
                    <td style="border: 1px solid #ddd; padding: 8px;">${royaltyCategory}</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">${productTitle}</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">${orderNumber}</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">${tranDate}</td>
                    <td style="border: 1px solid #ddd; padding: 8px; text-align: right;">${quantity}</td>
                    <td style="border: 1px solid #ddd; padding: 8px; text-align: right;">$${formatAmount(rate)}</td>
                    <td style="border: 1px solid #ddd; padding: 8px; text-align: right;">$${formatAmount(grossSale)}</td>
                    <td style="border: 1px solid #ddd; padding: 8px; text-align: right;">$${formatAmount(discounts)}</td>
                    <td style="border: 1px solid #ddd; padding: 8px; text-align: right; ${result.hasReturns ? 'color: red;' : ''}">$${formatAmount(result.returns || 0)}</td>
                    <td style="border: 1px solid #ddd; padding: 8px; text-align: right;">$${formatAmount(netSales)}</td>
                    <td style="border: 1px solid #ddd; padding: 8px; text-align: right;">$${formatAmount(taxes)}</td>
                    <td style="border: 1px solid #ddd; padding: 8px; text-align: right;">$${formatAmount(totalSales)}</td>                    
                    <td style="border: 1px solid #ddd; padding: 8px; text-align: right;">$${formatAmount(result.totalCost)}</td>                    
                </tr>
            `;
                    });
                    // Add total rows
                    tableHtml += `
            <tr>
                <td colspan="12" style="border: 1px solid #ddd; padding: 8px; text-align: right; font-weight: bold;">Total Gross Sales:</td>
                <td style="border: 1px solid #ddd; padding: 8px; text-align: right; font-weight: bold;">$${formatAmount(totals.totalGross)}</td>
            </tr>
            <tr>
                <td colspan="12" style="border: 1px solid #ddd; padding: 8px; text-align: right; font-weight: bold;">Total Net Sales:</td>
                <td style="border: 1px solid #ddd; padding: 8px; text-align: right; font-weight: bold;">$${formatAmount(totals.totelNet)}</td>
            </tr>
            <tr>
                <td colspan="12" style="border: 1px solid #ddd; padding: 8px; text-align: right; font-weight: bold;">Total Sales:</td>
                <td style="border: 1px solid #ddd; padding: 8px; text-align: right; font-weight: bold;">$1000</td>
            </tr>
            <tr>
                <td colspan="12" style="border: 1px solid #ddd; padding: 8px; text-align: right; font-weight: bold;">Total Cost:</td>
                <td style="border: 1px solid #ddd; padding: 8px; text-align: right; font-weight: bold;">$1000</td>
            </tr>
            <tr>
                <td colspan="12" style="border: 1px solid #ddd; padding: 8px; text-align: right; font-weight: bold;">Total Profit:</td>
                <td style="border: 1px solid #ddd; padding: 8px; text-align: right; font-weight: bold;">$1000</td>
            </tr>
            <tr>
                <td colspan="12" style="border: 1px solid #ddd; padding: 8px; text-align: right; font-weight: bold;">Split(%):</td>
                <td style="border: 1px solid #ddd; padding: 8px; text-align: right; font-weight: bold;">$1000</td>
            </tr>
        `;
                } else {
                    tableHtml = `
            <tr>
                <td colspan="14" style="border: 1px solid #ddd; padding: 8px; text-align: center;">
                    No results found for the selected criteria.
                </td>
            </tr>
        `;
                }

                // Update the HTML field with the results
                const resultsHtml = `
        <div class="uir-field-wrapper uir-long-text" style="margin-top: 20px;">
            <div class="uir-field">
                <span class="smalltextb">Royalty Report Results</span>
                <div class="uir-field-value">
                    <table id="custpage_royalty_results" class="uir-table" style="width: 100%; margin-top: 10px; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f5f7fa;">Royalty Category</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f5f7fa;">Product</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f5f7fa;">Order #</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f5f7fa;">Date</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f5f7fa;">Quantity</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f5f7fa;">Rate</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f5f7fa;">Gross Sales</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f5f7fa;">Discounts</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f5f7fa;">Returns</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f5f7fa;">Net Sales</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f5f7fa;">Taxes</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f5f7fa;">Total Sales</th>                                
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f5f7fa;">Total Cost</th>  
                            </tr>
                        </thead>
                        <tbody id="custpage_results_body">
                            ${tableHtml}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    `;

                form.getField({ id: 'custpage_results_html' }).defaultValue = resultsHtml;

            } catch (e) {
                log.error('Error generating report', e);
                form.getField({ id: 'custpage_results_html' }).defaultValue = `
        <div style="color: red; padding: 10px;">
            Error generating report: ${e.message}
        </div>
    `;
            }
        };

        /**
 * Processes and combines sales and returns data for reporting
 * @param {Array} salesData - Array of sales transactions
 * @param {Array} returnsData - Array of return/refund transactions
 * @returns {Array} - Processed data ready for report display
 */
        const processReportData = (salesData, returnsData) => {
            try {
                log.debug('Processing report data', `Sales: ${salesData.length}, Returns: ${returnsData.length}`);

                // Create a map to group returns by their original order number
                const returnsByOrderNumber = new Map();

                // Process returns data to build the lookup map
                returnsData.forEach(returnItem => {
                    if (!returnItem.orderNumber) return; // Skip returns with no reference

                    const orderNum = returnItem.orderNumber;
                    if (!returnsByOrderNumber.has(orderNum)) {
                        returnsByOrderNumber.set(orderNum, {
                            totalAmount: 0,
                            items: []
                        });
                    }

                    // Add this return's amount (already negative from getReturnsData)
                    const returnAmount = parseFloat(returnItem.grossSale) || 0;
                    const group = returnsByOrderNumber.get(orderNum);

                    group.totalAmount += returnAmount; // Will be negative
                    group.items.push(returnItem);

                    // Debug log for each return item being processed
                    log.emergency('Return Item for Order ' + orderNum, {
                        orderNumber: orderNum,
                        productTitle: returnItem.productTitle,
                        returnAmount: returnAmount,
                        runningTotal: group.totalAmount
                    });
                });

                // Log the final returns mapping
                returnsByOrderNumber.forEach((value, key) => {
                    log.emergency('Returns Map Entry', {
                        orderNumber: key,
                        totalReturnsAmount: value.totalAmount,
                        numberOfReturnItems: value.items.length
                    });
                });

                // Enhance sales data with return information
                const enhancedSales = salesData.map(sale => {
                    const returns = returnsByOrderNumber.get(sale.orderNumber);
                    const returnAmount = returns ? returns.totalAmount : 0; // Will be negative amount

                    const hasReturns = !!returns;

                    // Only log details for sales with returns
                    if (hasReturns) {
                        log.emergency('Sale with Returns', {
                            orderNumber: sale.orderNumber,
                            productTitle: sale.productTitle,
                            saleAmount: sale.amountNetOfTax,
                            returnAmount: returnAmount,
                            returns_absolute: Math.abs(returnAmount),
                            netAfterReturns: parseFloat(sale.amountNetOfTax || 0) + returnAmount
                        });

                        // Log each return item that applies to this sale
                        if (returns && returns.items && returns.items.length > 0) {
                            returns.items.forEach((item, index) => {
                                log.emergency(`Return Item ${index + 1} for Sale ${sale.orderNumber}`, {
                                    productTitle: item.productTitle,
                                    returnDate: item.tranDate,
                                    quantity: item.quantity,
                                    amountNetOfTax: item.amountNetOfTax
                                });
                            });
                        }
                    }

                    return {
                        ...sale,
                        returns: Math.abs(returnAmount), // Convert to positive for display
                        returnsAmount: returnAmount, // Keep negative for calculations
                        netAfterReturns: parseFloat(sale.amountNetOfTax || 0) + returnAmount, // Subtract return amount
                        hasReturns: hasReturns
                    };
                });

                // Rest of the function remains the same...
                // Track which returns we've matched to sales
                const processedOrderNumbers = new Set(salesData.map(sale => sale.orderNumber));

                // Find "orphaned" returns (returns without matching sales in our data)
                const orphanedReturns = returnsData.filter(ret =>
                    ret.orderNumber && !processedOrderNumbers.has(ret.orderNumber)
                );

                // Log orphaned returns summary
                if (orphanedReturns.length > 0) {
                    log.emergency('Orphaned Returns Summary', {
                        count: orphanedReturns.length,
                        orderNumbers: orphanedReturns.map(r => r.orderNumber)
                    });
                }

                // Process orphaned returns
                const processedOrphanedReturns = orphanedReturns.map(ret => ({
                    ...ret,
                    isOrphanedReturn: true,
                    returns: 0,
                    netAfterReturns: parseFloat(ret.amountNetOfTax || 0) // Already negative
                }));

                // Combine results and return
                return [...enhancedSales, ...processedOrphanedReturns];

            } catch (e) {
                log.error('Error in processReportData', e);
                // Return the original sales data as fallback
                return [...salesData, ...returnsData];
            }
        };

        /**
         * Exports the report data to CSV format
         * @param {Object} scriptContext - The script context
         * @returns {boolean} - Whether to continue with form rendering
         */
        const exportReportToCSV = (scriptContext) => {
            const request = scriptContext.request;
            const response = scriptContext.response;

            const fromDate = request.parameters.custpage_date_from;
            const toDate = request.parameters.custpage_date_to;
            const categoryId = request.parameters.custpage_category;

            try {
                // Build the query based on filters (same as in generateReport)
                let sql = `
            SELECT
                item.itemid AS item_name,
                royalty.name AS category_name,
                CASE
                    WHEN trans.type = 'InvAdjst' THEN 'Inventory Adjustment'
                    WHEN trans.type = 'ItemRcpt' THEN 'Item Receipt'
                    WHEN trans.type = 'ItemShip' THEN 'Item Fulfillment'
                    WHEN trans.type = 'CustInvc' THEN 'Invoice'
                    ELSE trans.type
                END AS transaction_type,
                TO_CHAR(trans.trandate, 'MM/DD/YYYY') AS transaction_date,
                tline.amount AS line_amount,
                ROUND(tline.amount * (royalty.custrecord_tsc_royalty_percent / 100), 2) AS royalty_amount
            FROM
                transaction trans
            INNER JOIN
                transactionline tline ON trans.id = tline.transaction
            INNER JOIN
                item ON tline.item = item.id
            INNER JOIN
                customrecord_tsc_royalty royalty ON item.custitem_tsc_royalty = royalty.id
            WHERE
                trans.voided = 'F'
        `;

                // Add date range filters if provided
                const params = [];

                if (fromDate) {
                    sql += ` AND trans.trandate >= TO_DATE(?, 'MM/DD/YYYY')`;
                    params.push(fromDate);
                }

                if (toDate) {
                    sql += ` AND trans.trandate <= TO_DATE(?, 'MM/DD/YYYY')`;
                    params.push(toDate);
                }

                // Add category filter if provided
                if (categoryId) {
                    sql += ` AND royalty.id = ?`;
                    params.push(categoryId);
                }

                // Add order by clause
                sql += `
            ORDER BY
                trans.trandate DESC,
                item.itemid ASC
        `;

                // Run the query
                const queryResults = query.runSuiteQL({
                    query: sql,
                    params: params
                });

                // Get the results
                const results = queryResults.asMappedResults();

                // Generate CSV content
                let csvContent = 'Item Name,Category,Transaction,Date,Amount,Royalty\n';

                results.forEach(result => {
                    csvContent += `"${result.item_name || ''}","${result.category_name || ''}","${result.transaction_type || ''}","${result.transaction_date || ''}","${formatAmount(result.line_amount)}","${formatAmount(result.royalty_amount)}"\n`;
                });

                // Set response headers for CSV download
                response.setHeader({
                    name: 'Content-Type',
                    value: 'application/csv'
                });

                response.setHeader({
                    name: 'Content-Disposition',
                    value: 'attachment; filename="royalty_report.csv"'
                });

                // Write CSV content to response
                response.write(csvContent);

                // Return false to prevent form rendering
                return false;

            } catch (e) {
                log.error('Error exporting CSV', e);

                // Write error message
                response.write('Error exporting CSV: ' + e.message);

                // Return false to prevent form rendering
                return false;
            }
        };

        /**
         * Helper function to format amount with two decimal places
         * @param {number|string} amount - The amount to format
         * @returns {string} - The formatted amount
         */
        const formatAmount = (amount) => {
            if (!amount) return '0.00';

            const num = parseFloat(amount);
            return num.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        };



        return { onRequest };
    });